---
layout: post
title: 'Google Wire: Compile-time Dependency Injection for Go'
categories: '系统设计'
tags:
  - [系统设计, 依赖注入, 设计模式]
---

[Wire](https://github.com/google/wire) 是一个轻巧的Golang依赖注入工具。它由Go Cloud团队开发，通过自动生成代码的方式在编译期完成依赖注入。[依赖注入](https://en.wikipedia.org/wiki/Dependency_injection)是保持软件 “低耦合、易维护” 的重要设计准则之一。



<br>

## Wire入门

### Provider

provider是**生成组件的普通方法**。这些方法**接收所需依赖作为参数**，**创建组件**并将其**返回**。

组件可以是对象或函数 —— 事实上它可以是任何类型，但单一类型在整个依赖图中只能有单一provider。因此返回 `int` 类型的provider 不是个好主意。对于这种情况， 可以通过定义类型别名来解决。例如先定义`type Category int` ，然后让 provider 返回 `Category` 类型。

一个Provider的例子如下：

````go
// main.go
package main

type Foo struct {
	X int
}

// ProvideFoo returns a Foo.
func ProvideFoo() Foo {
	return Foo{X: 42}
}

type Bar struct {
	X int
}

// ProvideBar returns a Bar: a negative Foo.
func ProvideBar(foo Foo) Bar {
	return Bar{X: -foo.X}
}

type Baz struct {
	X int
}

// ProvideBaz returns a value if Bar is not zero.
func ProvideBaz(bar Bar) (Baz, error) {
	if bar.X == 0 {
		return Baz{}, errors.New("cannot provide baz when bar is zero")
	}
	return Baz{X: bar.X}, nil
}
````

<br>

### Injector

由`wire`自动生成的函数。函数内部会按根据依赖顺序调用相关privoder 。为了生成此函数， 我们在 `wire.go` (文件名非强制，但一般约定如此)文件中定义injector函数签名。 然后在函数体中调用`wire.Build` ，并以所需provider作为参数（无须考虑顺序）。

对于上述provider可以构建如下的Injector：

```go
// wire.go
package main

func InjectorBaz() (Baz, error) {
	wire.Build(SuperSet)
	return Baz{}, nil
}
```

在当前文件夹下运行指令`wire`就会生成文件`wire_gen.go`：

```go
// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//+build !wireinject

package main

// Injectors from wire.go:
func InjectorBaz() (Baz, error) {
	foo := ProvideFoo()
	bar := ProvideBar(foo)
	baz, err := ProvideBaz(bar)
	if err != nil {
		return Baz{}, err
	}
	return baz, nil
}
```

注意这份生成的代码：

1. `// +build\ wireinject` ，这个 [build tag](https://godoc.org/go/build#hdr-Build_Constraints) 确保在常规编译时忽略wire.go 文件。 与之相对的是 wire_gen.go 中的 `//+build\ !wireinject` 。两组对立的build tag保证在任意情况下， wire.go 与 wire_gen.go 只有一个文件生效， 避免了“UserLoader方法被重复定义”的编译错误。
2. `//go: generate `，使得我们在之后的生成中可以使用 `go generate` 来进行生成

<br>

## 高级应用

### 结构体Provider

结构体Provider可以利用给定的数据类型进行目标结构体构造，如下所示：

```go
type Foo int
type Bar int

func ProvideFoo() Foo {/* ... */}

func ProvideBar() Bar {/* ... */}

type FooBar struct {
    MyFoo Foo
    MyBar Bar
}

var Set = wire.NewSet(
    ProvideFoo,
    ProvideBar,
    wire.Struct(new(FooBar), "MyFoo", "MyBar"))
```

其中`wire.Struct`的第一个参数是指向目标结构体空间的一个指针，后面是该结构体需要进行依赖注入的字段名。如果使用 `wire.Struct(new(FooBar), "*")` 则代表需要注入所有字段。在字段后面加上tag `` `wire:"-"` ``就会排除该字段。

这样生成出来的`Injector`为：

```go
func injectFooBar() FooBar {
    foo := ProvideFoo()
    bar := ProvideBar()
    fooBar := FooBar{
        MyFoo: foo,
        MyBar: bar,
    }
    return fooBar
}
```

<br>

### 绑定值

在初始化结构体的时候，经常需要给字段一些初始值，这种情况可以理解为注入的依赖是一些常量，此时如果写Provider函数就显得比较冗余。Wire提供了简易的解决方案，可以使用 `wire.Value` 表达式来进行构建：

```go
// provider 和 injector
type Foo struct {
    X int
}

func injectFoo() Foo {
    wire.Build(wire.Value(Foo{X: 42}))
    return Foo{}
}

// 生成的代码
func injectFoo() Foo {
    foo := _wireFooValue
    return foo
}

var (
    _wireFooValue = Foo{X: 42}
)
```

对于接口则可以用`wire.InterfaceValue`进行赋值

<br>

### 清除函数

如果Provider中创建了一个对象必须被清除 (比如：关闭文件) ，那么他可以返回一个闭包函数去清理该对象：

```go
func provideFile(log Logger, path Path) (*os.File, func(), error) {
    f, err := os.Open(string(path))
    if err != nil {
        return nil, nil, err
    }
    cleanup := func() {
        if err := f.Close(); err != nil {
            log.Log(err)
        }
    }
    return f, cleanup, nil
}
```

<br>

## 参考资料

1. https://github.com/google/wire/blob/main/docs/guide.md